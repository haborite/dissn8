#!/usr/bin/env python
# Copyright (C) 2016  Vincent Pelletier <plr.vincent@gmail.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
"""
FOR INTERACTIVE USE ONLY !
This is not a python module, do not import it - run it.
"""
from __future__ import print_function
import argparse
from collections import defaultdict
import ConfigParser
import itertools
import os
from struct import unpack
import sys

ram_range_symbol_list = []
rom_symbol_dict = {}
entry_stack = []
comment_dict = {}

NUL_SPACE = None # No operand
ZRO_SPACE = 0    # Operand is zero-page ram address
RAM_SPACE = 1    # Operand is ram address
ROM_SPACE = 2    # Operand is rom address
IMM_SPACE = 3    # Operand is immediate value

caller_dict = defaultdict(list)
jumper_dict = defaultdict(list)
missing_ram_symbol_dict = defaultdict(list)
function_dict = {}
line_ownership_dict = {}
jump_dict = {}

def expandRange(value):
    if not value:
        return {}
    return {
        item
        for boundary_list in (
            span.split("-") for span in value.split(",")
        )
        for item in xrange(
            int(boundary_list[0].strip(), 0),
            int(boundary_list[-1].strip(), 0) + 1,
        )
    }

def asPrintable(value):
    if 0x20 <= value < 0x7f:
        return chr(value)
    return '.'

def NONXT(addr, operand, function):
    """
    There is no fixed next-instruction address (RET & RETI).
    """
    pass
def NEXTI(addr, operand, function):
    """
    Always execute next instruction (normal instructions).
    """
    entry_stack.append((addr + 1, function))
def BRNCH(addr, operand, function):
    """
    Execute next instruction or the one after that (conditional branches).
    """
    entry_stack.append((addr + 1, function))
    entry_stack.append((addr + 2, function))
def JUMPI(addr, operand, function):
    """
    Jump to some far address (unconditional branches).
    Keep track of what jumped to where and declare a label if missing.
    """
    entry_stack.append((operand, function))
    jumper_dict[operand].append(addr)
    if operand not in rom_symbol_dict:
        if function is None:
            offset = -1 # systematic disassembler, force absolute labels
        else:
            offset = operand - function_dict[function]
        rom_symbol_dict[operand] = (
            '%s_%04x' % (function, offset)
            if offset >= 0 else
            '_label_%04x' % operand
        )
def CALLI(addr, operand, function):
    """
    Call some address (call instructions).
    Keep track of what called where and declare a label if missing.
    """
    callee_name = rom_symbol_dict.setdefault(operand, 'func_%04x' % operand)
    if callee_name in function_dict:
        assert function_dict[callee_name] == operand, (
            callee_name,
            function_dict[operand],
            operand,
        )
    else:
        function_dict[callee_name] = operand
    entry_stack.append((operand, callee_name))
    entry_stack.append((addr + 1, function))
    caller_dict[operand].append(addr)

opcode_dict = {
    0x00: (0x0000, NUL_SPACE, None, NEXTI, 'NOP',    None),
    0x02: (0x00ff, ZRO_SPACE, 'rw', NEXTI, 'B0XCH',  'A, %s'),
    0x03: (0x00ff, ZRO_SPACE, 'rw', NEXTI, 'B0ADD',  '%s, A'),
    0x04: (0x0000, NUL_SPACE, None, NEXTI, 'PUSH',   None),
    0x05: (0x0000, NUL_SPACE, None, NEXTI, 'POP',    None),
    0x06: (0x00ff, IMM_SPACE, None, BRNCH, 'CMPRS',  'A, %s'),
    0x07: (0x00ff, RAM_SPACE, 'r ', BRNCH, 'CMPRS',  'A, %s'),
    0x08: (0x00ff, RAM_SPACE, 'r ', NEXTI, 'RRC',    '%s'),
    0x09: (0x00ff, RAM_SPACE, 'rw', NEXTI, 'RRCM',   '%s'),
    0x0a: (0x00ff, RAM_SPACE, 'r ', NEXTI, 'RLC',    '%s'),
    0x0b: (0x00ff, RAM_SPACE, 'rw', NEXTI, 'RLCM',   '%s'),
    0x0d: (0x0000, NUL_SPACE, None, NEXTI, 'MOVC',   None),
    0x0e: (0x0000, NUL_SPACE, None, NONXT, 'RET',    None),
    0x0f: (0x0000, NUL_SPACE, None, NONXT, 'RETI',   None),
    0x10: (0x00ff, RAM_SPACE, 'r ', NEXTI, 'ADC',    'A, %s'),
    0x11: (0x00ff, RAM_SPACE, 'rw', NEXTI, 'ADC',    '%s, A'),
    0x12: (0x00ff, RAM_SPACE, 'r ', NEXTI, 'ADD',    'A, %s'),
    0x13: (0x00ff, RAM_SPACE, 'rw', NEXTI, 'ADD',    '%s, A'),
    0x14: (0x00ff, IMM_SPACE, None, NEXTI, 'ADD',    'A, %s'),
    0x15: (0x00ff, RAM_SPACE, 'r ', BRNCH, 'INCS',   '%s'),
    0x16: (0x00ff, RAM_SPACE, 'rw', BRNCH, 'INCMS',  '%s'),
    0x17: (0x00ff, RAM_SPACE, 'r ', NEXTI, 'SWAP',   '%s'),
    0x18: (0x00ff, RAM_SPACE, 'r ', NEXTI, 'OR',     'A, %s'),
    0x19: (0x00ff, RAM_SPACE, 'rw', NEXTI, 'OR',     '%s, A'),
    0x1a: (0x00ff, IMM_SPACE, None, NEXTI, 'OR',     'A, %s'),
    0x1b: (0x00ff, RAM_SPACE, 'r ', NEXTI, 'XOR',    'A, %s'),
    0x1c: (0x00ff, RAM_SPACE, 'rw', NEXTI, 'XOR',    '%s, A'),
    0x1d: (0x00ff, IMM_SPACE, None, NEXTI, 'XOR',    'A, %s'),
    0x1e: (0x00ff, RAM_SPACE, 'r ', NEXTI, 'MOV',    'A, %s'),
    0x1f: (0x00ff, RAM_SPACE, ' w', NEXTI, 'MOV',    '%s, A'),
    0x20: (0x00ff, RAM_SPACE, 'r ', NEXTI, 'SBC',    'A, %s'),
    0x21: (0x00ff, RAM_SPACE, 'rw', NEXTI, 'SBC',    '%s, A'),
    0x22: (0x00ff, RAM_SPACE, 'r ', NEXTI, 'SUB',    'A, %s'),
    0x23: (0x00ff, RAM_SPACE, 'rw', NEXTI, 'SUB',    '%s, A'),
    0x24: (0x00ff, IMM_SPACE, None, NEXTI, 'SUB',    'A, %s'),
    0x25: (0x00ff, RAM_SPACE, 'r ', BRNCH, 'DECS',   '%s'),
    0x26: (0x00ff, RAM_SPACE, 'rw', BRNCH, 'DECMS',  '%s'),
    0x27: (0x00ff, RAM_SPACE, 'rw', NEXTI, 'SWAPM',  '%s'),
    0x28: (0x00ff, RAM_SPACE, 'r ', NEXTI, 'AND',    'A, %s'),
    0x29: (0x00ff, RAM_SPACE, 'rw', NEXTI, 'AND',    '%s, A'),
    0x2a: (0x00ff, IMM_SPACE, None, NEXTI, 'AND',    'A, %s'),
    0x2b: (0x00ff, RAM_SPACE, ' 0', NEXTI, 'CLR',    '%s'),
    0x2c: (0x00ff, RAM_SPACE, 'rw', NEXTI, 'XCH',    'A, %s'),
    0x2d: (0x00ff, IMM_SPACE, None, NEXTI, 'MOV',    'A, %s'),
    0x2e: (0x00ff, ZRO_SPACE, 'r ', NEXTI, 'B0MOV',  'A, %s'),
    0x2f: (0x00ff, RAM_SPACE, ' w', NEXTI, 'B0MOV',  '%s, A'),
    0x32: (0x00ff, IMM_SPACE, None, NEXTI, 'B0MOV',  'R, %s'),
    0x33: (0x00ff, IMM_SPACE, None, NEXTI, 'B0MOV',  'Z, %s'),
    0x34: (0x00ff, IMM_SPACE, None, NEXTI, 'B0MOV',  'Y, %s'),
    0x36: (0x00ff, IMM_SPACE, None, NEXTI, 'B0MOV',  'PFLAG, %s'),
    0x37: (0x00ff, IMM_SPACE, None, NEXTI, 'B0MOV',  'RBANK, %s'),
    0x40: (0x00ff, RAM_SPACE, ' 0', NEXTI, 'BCLR',   '%s'),
    0x48: (0x00ff, RAM_SPACE, ' 1', NEXTI, 'BSET',   '%s'),
    0x50: (0x00ff, RAM_SPACE, 'r ', BRNCH, 'BTS0',   '%s'),
    0x58: (0x00ff, RAM_SPACE, 'r ', BRNCH, 'BTS1',   '%s'),
    0x60: (0x00ff, ZRO_SPACE, ' 0', NEXTI, 'B0BCLR', '%s'),
    0x68: (0x00ff, ZRO_SPACE, ' 1', NEXTI, 'B0BSET', '%s'),
    0x70: (0x00ff, ZRO_SPACE, 'r ', BRNCH, 'B0BTS0', '%s'),
    0x78: (0x00ff, ZRO_SPACE, 'r ', BRNCH, 'B0BTS1', '%s'),
    0x80: (0x3fff, ROM_SPACE, None, JUMPI, 'JMP',    '%s'),
    0xc0: (0x3fff, ROM_SPACE, None, CALLI, 'CALL',   '%s'),
}

branch_opcode_implicit_operand_dict = {
    0x06: 'A',
    0x07: 'A',
    0x15: '0',
    0x16: '0',
    0x25: '0',
    0x26: '0',
    0x50: '0',
    0x58: '1',
    0x70: '0',
    0x78: '1',
}

def disassemble(address, instruction, function):
    bincode = instruction >> 8
    if bincode >= 0x80:
        opcode_key = bincode & 0xc0
        is_bit = False
    elif bincode >= 0x40:
        opcode_key = bincode & 0xf8
        is_bit = True
    else:
        opcode_key = bincode
        is_bit = False
    try:
        mask, opspace, opmode, jump_action, opcode, caption = opcode_dict[opcode_key]
    except KeyError:
        NEXTI(address, None)
        return 'DW\t0x%04x\t; ILLEGAL OPCODE' % (instruction, )
    if opspace == NUL_SPACE:
        jump_action(address, None, function)
        if jump_action is NONXT:
            jump_dict[address] = ()
    else:
        operand = instruction & mask
        jump_action(address, operand, function)
        if opspace == ROM_SPACE:
            symbol = rom_symbol_dict.get(operand)
            operand_fmt = '0x%04x'
            assert not is_bit
        elif opspace == IMM_SPACE:
            symbol = None
            operand_fmt = '#0x%02x'
            assert not is_bit
        else: # ZRO & RAM
            bit_dict = {}
            symbol = None
            for start, stop, ram_symbol_dict in ram_range_symbol_list:
                if start <= address <= stop and operand in ram_symbol_dict:
                    range_symbol, range_bit_dict = ram_symbol_dict[operand]
                    if symbol is None:
                        symbol = range_symbol
                    for bit_address, bit_symbol in range_bit_dict.iteritems():
                        bit_dict.setdefault(bit_address, bit_symbol)
            operand_fmt = '0x%02x'
            if is_bit:
                bit_address = bincode & 0x7
                bit_symbol = bit_dict.get(bit_address)
                if bit_symbol is None:
                    if symbol is None:
                        operand_fmt += '.%i' % bit_address
                    else:
                        symbol += '.%i' % bit_address
                else:
                    symbol = bit_symbol
        if symbol is None:
            symbol = operand_fmt % operand
            if opspace in (ZRO_SPACE, RAM_SPACE):
                missing_ram_symbol_dict[symbol].append((address, opmode))
        if jump_action is BRNCH:
            implicit_operand = branch_opcode_implicit_operand_dict[opcode_key]
            if implicit_operand == 'A':
                lhs = implicit_operand
                rhs = symbol
            else:
                lhs = symbol
                rhs = implicit_operand
            jump_dict[address] = (
                (address + 1, '%s != %s' % (lhs, rhs), 'red'),
                (address + 2, '%s == %s' % (lhs, rhs), 'green'),
            )
        elif jump_action is JUMPI:
            jump_dict[address] = (
                (operand, None, 'black'),
            )
        opcode += '\t' + caption % symbol
    return opcode

def systematic(rom):
    disassembled = {}
    for address, instruction in rom.iteritems():
        try:
            opcode = disassemble(address, instruction, None)
        except KeyError:
            opcode = 'DW\t0x%04x\t; %s%s' % (
                instruction,
                asPrintable(instruction >> 8),
                asPrintable(instruction & 0xff),
            )
        disassembled[address] = opcode
    return disassembled

def walker(rom):
    disassembled = {}
    while entry_stack:
        address, function = entry_stack.pop()
        try:
            instruction = rom.pop(address)
        except KeyError:
            continue # Already disassembled
        line_owner = line_ownership_dict.setdefault(address, function)
        if line_owner != function:
            print(
                'Line ownership disagreement: 0x%04x claimed by %r and %r' % (
                    address,
                    line_ownership_dict[address],
                    function,
                ),
            )
            function = line_owner
        if instruction in (
                    0x03ce, # B0ADD PCL, A
                    0x13ce, # ADD   PCL, A
                ):
            # A jump table follows.
            # XXX: assumes jump tables are only composed of JMP (0x8000),
            # CALL (0xc000) and NOP (0x0000). Jump table is supposed to end
            # at the first unexpected instruction, meaning that the code
            # after the last entry will not be jumped to as part of the
            # table.
            for sub_address in itertools.count(address + 1):
                if sub_address in disassembled:
                    continue
                if rom[sub_address] & 0x8000 or rom[sub_address] == 0x0000:
                    entry_stack.append((sub_address, function))
                else:
                    break
        disassembled[address] = disassemble(address, instruction, function)
    # Convert any disassembled word into a data word.
    # Agglutinate non-disassembled portions to know their length.
    # Ignore runs of nulls longer than 6 words (12 bytes), for readability.
    # XXX: 6 words is a totally arbitrary value.
    data_chunk_dict = defaultdict(list)
    next_address = None
    current_chunk = None
    for address, value in sorted(rom.iteritems()):
        if address != next_address:
            current_chunk = data_chunk_dict[address]
        next_address = address + 1
        current_chunk.append(value)
    for chunk_address, value_list in data_chunk_dict.iteritems():
        for count, value in [
                    (len(list(g)), k) for k, g in itertools.groupby(value_list)
                ]:
            if value or count < 7:
                for offset in xrange(count):
                    disassembled[chunk_address + offset] = (
                        'DW\t0x%04x\t; %s%s' % (
                            value,
                            asPrintable(value >> 8),
                            asPrintable(value & 0xff),
                        )
                    )
            chunk_address += count
    return disassembled

def tabstop(prefix, position, suffix, tabwidth=8):
    """
    Returns <prefix> and <suffix> so that <suffix> starts at tabstop
    <position>.
    """
    tabcount = max(0, position - len(prefix.expandtabs(tabwidth)) // tabwidth)
    return prefix + (
      '\t' * tabcount
      if tabcount else
      ' '
    ) + suffix
COMMENT_POSITION = 5 # 5th tab

def getFunctionNameAndOffset(address):
    function_name = line_ownership_dict[address]
    return '%s%#+x' % (function_name, address - function_dict[function_name])

class CasedSafeConfigParser(ConfigParser.SafeConfigParser):
    @staticmethod
    def optionxform(optionstr):
        return optionstr

def main():
    method_dict = {
        'walker': walker,
        'systematic': systematic,
    }

    parser = argparse.ArgumentParser(description='SN8F228(8|3|31) USB 2.0'
        ' full-speed 8-bits microcontroller disassembler')
    parser.add_argument('-c', '--chip', action='append', required=True,
        type=argparse.FileType('r'), help='Chip definition (name, regisers, '
            'labels, comments). Document disassembled code in a separate '
            'configuration file to automatically re-annotate on next '
            'disassembly. Can be specified multiple time, files will be '
            'loaded and merged in memory in the order they are specified.')
    parser.add_argument('-m', '--method', default='walker', choices=method_dict,
        help='Disassembly strategy: "walker" follows code path to avoid '
            'disassembling data, "systematic" just disassembes all memory. '
            'Default: %(default)s.')
    parser.add_argument('-H', '--skip-header', action='store_true',
        help='Skip the SH8 header used by SN8 C Studio for object files')
    parser.add_argument('-o', '--output', type=argparse.FileType('w'),
        default=sys.stdout, help='Path to write assembly code to, or - '
            'for stdout (default).')
    parser.add_argument('--dot', action='store_true',
        help='Write function graphs in dot format in <basename(input)> folder.')
    parser.add_argument('input', type=argparse.FileType('rb'), nargs='?',
        default=sys.stdin, help='Path of binary rom image file to '
            'disassemble, or - for stdin (default).')
    args = parser.parse_args()
    write = args.output.write

    chip_config = CasedSafeConfigParser()
    for chip_file in args.chip:
        chip_config.readfp(chip_file)
    chip = {}
    for section_name in chip_config.sections():
        chip[section_name] = section = dict(chip_config.items(section_name))
        if section_name.startswith('ram'):
            if section_name.startswith('ram@'):
                _, ram_range = section_name.split('@')
                start, stop = ram_range.split('-')
            else:
                assert section_name in ('ram', 'ram-reserved'), repr(section_name)
                start = chip['chip']['rom_start']
                stop = chip['chip']['rom_stop']
            ram_range_symbol_list.append([int(start, 0), int(stop, 0), section])
    # Shorter ranges first, overriding larger maps
    ram_range_symbol_list.sort(key=lambda x: x[1] - x[0])
    # chip name must be set
    write('CHIP\t' + chip['chip']['name'] + '\n')
    rom_reserved_set = expandRange(chip['chip'].get('rom_reserved', ''))
    # Note: only look for duplicate ram symbols, not rom.
    flat_ram_symbol_dict = defaultdict(lambda: ([], defaultdict(list)))
    reverse_dict = {}
    for ram_range_symbol_entry in ram_range_symbol_list:
        _, _, ram_symbol_dict = ram_range_symbol_entry
        ram_range_symbol_entry[2] = new_ram_symbol_dict = {}
        for address, name in ram_symbol_dict.iteritems():
            if name:
                if reverse_dict.get(name, address) != address:
                    raise ValueError(
                        'Name %r is used for different addresses: %r and %r' % (
                            name, reverse_dict[name], address,
                        )
                    )
                reverse_dict[name] = address
            else:
                # To un-define a defined symbol, by giving an empty name.
                # Ex: to override register names over a piece of code using
                # non-zero bank. XXX: B0MOV will not properly resolve
                name = None
            if '.' in address:
                address, bit = address.split('.')
            else:
                bit = None
            address = int(address, 0)
            flat_name_list, flat_bit_dict = flat_ram_symbol_dict[address]
            try:
                entry = new_ram_symbol_dict[address]
            except KeyError:
                entry = new_ram_symbol_dict[address] = [None, {}]
            if bit is None:
                assert entry[0] is None, (address, name, entry)
                entry[0] = name
                flat_name_list.append(name)
            else:
                bit = int(bit)
                entry[1][bit] = name
                flat_bit_dict[bit].append(name)
    ram_reserved_name_set = {x for x in chip.get('ram-reserved', {}).itervalues()}
    rom_symbol_dict.update(
        (int(address, 0), name) for address, name in chip.get('rom', {}).iteritems()
    )
    function_addr_name_list = [
        (int(address, 0), name)
        for address, name in chip['callee'].iteritems()
    ]
    rom_symbol_dict.update(function_addr_name_list)
    line_ownership_dict.update(function_addr_name_list)
    function_dict.update((y, x) for x, y in function_addr_name_list)
    entry_stack.extend(line_ownership_dict.iteritems())
    comment_dict.update(
        (int(address, 0), comment)
        for address, comment in chip['comment'].iteritems()
    )
    for reserved in rom_reserved_set:
        comment_dict.setdefault(reserved, 'Reserved')
    read = args.input.read
    if args.skip_header:
        read(88)
    rom = {}
    rom_start = int(chip['chip']['rom_start'], 0)
    rom_stop = int(chip['chip']['rom_stop'], 0)
    for address in xrange(
        int(chip['chip']['rom_start'], 0),
        int(chip['chip']['rom_stop'], 0) + 1,
    ):
        instruction = read(2)
        if len(instruction) != 2:
            break
        rom[address], = unpack('<H', instruction)
    if read(1):
        print('Ignoring data past end of ROM')
    write('//{{SONIX_CODE_OPTION\n')
    for option_name, option_definition in chip['code-option'].iteritems():
        address, mask, value_names = option_definition.split(' ', 2)
        mask = int(mask, 0)
        assert mask
        try:
            option_value = rom[int(address, 0)] & mask
        except KeyError:
            continue
        while not mask & 1:
            mask >>= 1
            option_value >>= 1
        write(tabstop(
            '\t.Code_Option\t' + option_name,
            5,
            '"' + {
                int(value, 0): name
                for value, name in (x.split('=') for x in value_names.split(' '))
            }[option_value] + '"\n',
        ))
    write('//}}SONIX_CODE_OPTION\n')
    disassembled_dict = method_dict[args.method](rom)
    write('.DATA\n')
    for address, (flat_name_list, flat_bit_dict) in sorted(flat_ram_symbol_dict.iteritems()):
        for name in flat_name_list:
            if name in ram_reserved_name_set:
                continue
            write('%s\tEQU\t0x%02x\n' % (name, address))
        for bit_number, bit_name_list in sorted(flat_bit_dict.iteritems()):
            for bit_name in bit_name_list:
                if bit_name in ram_reserved_name_set:
                    continue
                write('%s\tEQU\t0x%02x.%i\n' % (bit_name, address, bit_number))
    if missing_ram_symbol_dict:
        write('; Missing ram symbols and list of users\n')
        for address, accessor_list in sorted(missing_ram_symbol_dict.iteritems()):
            write('; %s:\n' % (address, ) )
            for address, mode in sorted(accessor_list):
                write(';\t%s %s\n' % (
                    mode,
                    getFunctionNameAndOffset(address),
                ))
    write('.CODE\n')
    next_key = None
    dot = args.dot
    if dot:
        dot_dict = defaultdict(list)
        dot_path = os.path.splitext(args.input.name)[0]
        if not os.path.exists(dot_path):
          os.mkdir(dot_path)
        def dot_addline(address, line, is_instruction=True):
            try:
                function_id = line_ownership_dict[address]
            except KeyError:
                return
            dot_dict[function_id].append((
                address,
                (
                    (
                        ('%04x ' % address)
                        if is_instruction else
                        '     '
                    ) + line
                ).expandtabs(
                ).replace('\\', '\\\\'
                ).replace('"', '\\"'
                ) + '\\l',
                is_instruction,
            ))
        def dot_write():
            def writenode():
                node_id = '"' + getFunctionNameAndOffset(node_base_address) + '"'
                dot_file.write('%s[label="%s"]\n' % (
                    node_id,
                    ''.join(node_line_list)
                ))
                del node_line_list[:]
                return node_id
            jumped_set = {x for y in jump_dict.itervalues() for x, _, _ in y}
            for function, line_list in dot_dict.iteritems():
                with open(os.path.join(dot_path, function + '.dot'), 'w') as dot_file:
                    dot_file.write('strict digraph {\nedge [fontname="Courier"]\nnode [shape="box",fontname="Courier"]\n')
                    node_line_list = []
                    node_base_address = None
                    for address, line, is_instruction in line_list:
                        if node_base_address is None:
                            if is_instruction:
                                node_base_address = address
                        elif address in jumped_set:
                            node_id = writenode()
                            dot_file.write('%s->%s[color="black"]\n' % (
                                node_id,
                                '"' + getFunctionNameAndOffset(address) + '"',
                            ))
                            node_base_address = address if is_instruction else None
                        node_line_list.append(line)
                        if is_instruction and address in jump_dict:
                            node_id = writenode()
                            node_base_address = None
                            for to_address, label, color in jump_dict[address]:
                                dot_file.write('%s->%s[color="%s"' % (
                                    node_id,
                                    '"' + getFunctionNameAndOffset(to_address) + '"',
                                    color,
                                ))
                                if label:
                                    dot_file.write(',label="%s"' % label)
                                dot_file.write(']\n')
                    if node_line_list:
                        writenode()
                    dot_file.write('}\n')
    else:
        dot_addline = lambda x, y: None
        dot_write = lambda: None
    for key in sorted(disassembled_dict):
        disassembled = disassembled_dict[key]
        if key != next_key:
            if key in rom_reserved_set:
                write(';')
            write('ORG 0x%04x\n' % key)
        if not (key & 0xf):
            write(tabstop('', COMMENT_POSITION, '; 0x%04x\n' % key))
        next_key = key + 1
        if key in rom_symbol_dict:
            dot_addline(key, rom_symbol_dict[key] + ':', is_instruction=False)
            write(tabstop(rom_symbol_dict[key] + ':', COMMENT_POSITION, ';'))
            if key in caller_dict:
                write(' Called from ' + ', '.join(
                    getFunctionNameAndOffset(x)
                    for x in sorted(caller_dict.pop(key))
                ))
            if key in jumper_dict:
                write(' Jumped from ' + ', '.join(
                    getFunctionNameAndOffset(x)
                    for x in sorted(jumper_dict.pop(key))
                ))
            write('\n')
        else:
            assert key not in caller_dict, key
            assert key not in jumper_dict, key
        line = (';' if key in rom_reserved_set else '') + '\t' + disassembled
        if key in comment_dict:
            line = tabstop(line, COMMENT_POSITION, '; ' + comment_dict[key])
        write(line + '\n')
        dot_addline(key, line)
    dot_write()
    if caller_dict:
        write('; Unknown calls:\n')
        for address, caller_list in caller_dict.iteritems():
            write('ORG 0x%04x\n' % address)
            write(
                rom_symbol_dict[address] + ': ; Called from ' +
                ', '.join(
                    getFunctionNameAndOffset(x)
                    for x in caller_list
                ) + '\n'
            )
            write('\tJMP\t' + rom_symbol_dict[address] + '\n')
    if jumper_dict:
        write('; Unknown jumps:\n')
        for address, jumper_list in jumper_dict.iteritems():
            write('ORG 0x%04x\n' % address)
            write(
                rom_symbol_dict[address] + ': ; Jumped from ' +
                ', '.join(
                    getFunctionNameAndOffset(x)
                    for x in jumper_list
                ) + '\n'
            )
            write('\tJMP\t' + rom_symbol_dict[address] + '\n')
    write('ENDP\n')

if __name__ == '__main__':
    main()
